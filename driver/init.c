#include "init.h" // 包含了该模块相关的头文件

/**
 * @brief 系统硬件初始化函数
 * @note  该函数负责在程序开始时将所有外设设置为一个已知的、安全的初始状态。
 * 它主要操作P0口（数据口）和P2口（控制口）来关闭LED、继电器和蜂鸣器。
 * P2口的高3位(P2.7, P2.6, P2.5)通常用作138译码器的地址输入，来选择不同的外设组。
 */
void System_Init()
{
    unsigned char temp; // 定义一个临时变量，用于暂存P2口的状态

    // --- 第一步: 关闭所有LED灯 ---
    // 在典型的竞赛开发板上，138译码器的Y4输出（CBA=100）控制LED的使能。
    
    // 1. 设置数据口P0为全1。对于共阴极连接的LED，写入1表示熄灭。
    P0 = 0xff;
    
    // 2. 选择LED外设组进行操作
    temp = P2 & 0x1f;   // 读取P2口的当前状态，并屏蔽高3位（C,B,A），保留P2.0-P2.4的原状态。
                        // 0x1f = 0001 1111b
    temp = temp | 0x80;   // 将P2.7置1，P2.6和P2.5保持为0。即地址CBA=100。
                        // 0x80 = 1000 0000b
    P2 = temp;          // 将配置好的值写入P2口，此时138译码器的Y4输出有效，选中LED模块。
                        // P0上的数据(0xff)被送到LED驱动电路上。
    
    // 3. 取消外设选择，防止干扰
    temp = P2 & 0x1f;   // 再次屏蔽P2口的高3位，相当于将CBA清零。
    P2 = temp;          // 写入P2，此时138译码器选中Y0。如果Y0未连接任何外设，则所有外设均不被选中。
                        // 这个操作完成了对LED状态的“锁存”。

    // --- 第二步: 关闭继电器、蜂鸣器（和可能的电机）---
    // 在典型的竞赛开发板上，138译码器的Y5输出（CBA=101）控制这些杂项外设。
    
    // 1. 设置数据口P0为全0。对于继电器、蜂鸣器等，写入0通常表示关闭或不工作。
    P0 = 0x00;
    
    // 2. 选择继电器和蜂鸣器外设组
    temp = P2 & 0x1f;   // 同样地，先保留P2口的低5位状态。
    temp = temp | 0xa0;   // 将P2.7和P2.5置1，P2.6保持为0。即地址CBA=101。
                        // 0xa0 = 1010 0000b
    P2 = temp;          // 写入P2口，此时138译码器的Y5输出有效，选中继电器/蜂鸣器模块。
                        // P0上的数据(0x00)被送到这些外设的驱动电路上。
    
    // 3. 取消外设选择
    temp = P2 & 0x1f;   // 再次将P2口的高3位清零。
    P2 = temp;          // 写入P2，完成对继电器/蜂鸣器状态的“锁存”。
}