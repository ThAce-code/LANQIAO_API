/* #   单总线代码片段说明
    1.  本文件夹中提供的驱动代码供参赛选手完成程序设计参考。
    2.  参赛选手可以自行编写相关代码或以该代码为基础，根据所选单片机类型、运行速度和试题
        中对单片机时钟频率的要求，进行代码调试和修改。
*/
#include "onewire.h" // 包含了单总线相关的函数声明或宏定义

// 定义DS18B20的数据引脚DQ连接到单片机的P1.4口
sbit DQ = P1^4; 

/**
 * @brief 单总线协议专用延时函数
 * @param t 延时参数，数值越大，延时越长。
 * @note  这是一个软件循环延时，其实际延时时间与单片机的主时钟频率密切相关。
 * 代码中所有的延时参数都是基于特定的时钟频率调试得到的。
 */
void Delay_OneWire(unsigned int t)  
{
    unsigned char i;
    while(t--){
        // 内层循环是一个固定的短延时
        for(i=0; i<12; i++);
    }
}

/**
 * @brief 通过单总线向DS18B20写入一个字节
 * @param dat 要写入的字节数据
 * @note  数据从最低位(LSB)开始发送。这是一个简化的写时序实现。
 */
void Write_DS18B20(unsigned char dat)
{
    unsigned char i;
    for(i=0; i<8; i++) // 一个字节循环8次
    {
        DQ = 0; // 1. 主机拉低总线，开始一个“写时隙”
        // 2. 将要写入的数据位放到总线上。这是一个简化写法，
        //    通过极短的时间间隔实现0和1的写入。
        DQ = dat & 0x01; 
        Delay_OneWire(5); // 3. 延时，保持电平一段时间（大于60us）
        DQ = 1; // 4. 主机释放总线，准备下一个时隙
        dat >>= 1; // 5. 数据右移一位，准备发送下一位
    }
    Delay_OneWire(5); // 额外的恢复延时
}

/**
 * @brief 从DS18B20读取一个字节
 * @return unsigned char 返回读取到的字节数据
 * @note  数据从最低位(LSB)开始接收。
 */
unsigned char Read_DS18B20(void)
{
    unsigned char i;
    unsigned char dat;
 
    for(i=0; i<8; i++) // 循环8次，接收一个字节
    {
        DQ = 0; // 1. 主机拉低总线，开始一个“读时隙”
        dat >>= 1; // 2. 将数据变量右移一位，为即将到来的新数据腾出空间（新位将放在最高位）
        DQ = 1; // 3. 主机迅速释放总线，由DS18B20来控制总线电平
        
        // 4. 读取总线状态。如果DS18B20发送1，总线会被上拉电阻拉高；如果发送0，它会继续将总线拉低。
        if(DQ)
        {
            dat |= 0x80; // 5. 如果读到高电平(1)，则将数据变量的最高位置1
        }       
        Delay_OneWire(5); // 6. 延时，等待当前读时隙结束
    }
    return dat; // 7. 返回完整接收到的字节
}

/**
 * @brief 初始化DS18B20 (复位并检测存在)
 * @return bit 返回检测结果。0 表示成功检测到设备，1 表示失败（无设备响应）。
 */
bit init_ds18b20(void)
{
    bit initflag = 0; // 标志位，用于存储返回结果
    
    DQ = 1; // 1. 确保总线在开始时处于空闲状态（高电平）
    Delay_OneWire(12);
    DQ = 0; // 2. 主机将总线拉低，产生一个复位脉冲（需要持续至少480us）
    Delay_OneWire(80); // 这个延时提供了足够长的低电平时间
    DQ = 1; // 3. 主机释放总线，并进入接收模式
    Delay_OneWire(10); // 4. 延时等待，让DS18B20有机会响应
    
    // 5. 读取总线状态。如果DS18B20存在，它会拉低总线约60-240us作为响应（存在脉冲）。
    //    因此，如果读到DQ为0，表示设备存在。
    initflag = DQ;     
    Delay_OneWire(5); // 6. 等待存在脉冲结束
 
    return initflag; // 7. 返回标志位。0=成功, 1=失败
}

/**
 * @brief 读取当前温度值
 * @return float 返回一个浮点型的摄氏度温度值
 */
float rd_temperature()
{
    unsigned char high, low; // 用于存放温度数据的两个字节
    
    // --- 第一步: 发起温度转换 ---
    init_ds18b20();        // 1. 初始化总线
    Write_DS18B20(0xcc);   // 2. 发送 "Skip ROM" (跳过ROM)指令，表示命令将发给总线上唯一的设备
    Write_DS18B20(0x44);   // 3. 发送 "Convert T" (开始转换)指令
    
    // --- 第二步: 等待转换完成 ---
    // 温度转换需要时间（最高精度下可达750ms），必须提供一个足够的延时。
    Delay_OneWire(200); 
    
    // --- 第三步: 读取温度数据 ---
    init_ds18b20();        // 4. 再次初始化总线，开始新的通信
    Write_DS18B20(0xcc);   // 5. 再次发送 "Skip ROM" 指令
    Write_DS18B20(0xbe);   // 6. 发送 "Read Scratchpad" (读暂存器)指令
    low = Read_DS18B20();  // 7. 读取暂存器中的第0个字节（温度低8位）
    high = Read_DS18B20(); // 8. 读取暂存器中的第1个字节（温度高8位）
    
    // --- 第四步: 计算实际温度 ---
    // 9. 将高低字节合并成一个16位的有符号整数，然后乘以分辨率(12位时为0.0625)得到摄氏度。
    return (float)(high << 8 | low) * 0.0625;
}