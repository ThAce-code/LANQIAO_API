#include "seg.h" // 包含了数码管显示相关的头文件

// --- 数码管段码表 ---
// 使用 "pdata" 关键字建议编译器将此数组存储在分页外部数据存储器(XDATA的一页)中。
// 这是一个共阳极数码管的段码表。数组索引 0-9 对应数字 0-9，索引 10 对应熄灭。
// 共阳极数码管的段选线是低电平有效，所以字节中为'0'的位对应的LED段会点亮。
// 例如：seg_dula[0] = 0xc0 = 1100 0000b。如果段的顺序是 DP-G-F-E-D-C-B-A，
// 那么这个码值会点亮 a,b,c,d,e,f 段，熄灭 g,dp 段，从而显示出数字 '0'。
pdata unsigned char seg_dula[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff};

/**
 * @brief 数码管显示单次驱动函数
 * @param wela  位选参数 (0-7)，选择要点亮哪一位数码管。
 * @param dula  段选参数 (0-10)，选择要显示哪个数字（0-9）或熄灭（10）。
 * @param point 小数点使能位。如果为1(true)，则点亮该位的小数点。
 * @note  此函数每次只点亮一位数码管，需要在定时器中断或主循环中快速轮流调用来显示多位。
 */
void Seg_Disp(unsigned char wela, unsigned char dula, bit point)
{
    unsigned char temp; // 用于P2口操作的临时变量

    // --- 步骤 1: 消隐 (消除上一次显示的残影) ---
    // 在切换位选之前，先将所有段选都关闭，可以有效防止“鬼影”现象。
    P0 = 0xff; // P0口送出全1，对于共阳极数码管，这会熄灭所有段。
    
    // 使用138译码器选择段选锁存器（Y7输出，地址111）
    temp = P2 & 0x1f;   // 保留P2低5位原状态
    temp = temp | 0xe0;   // 设置P2高3位为111 (0xe0 = 1110 0000b)
    P2 = temp;          // 选中段选锁存器，将P0上的“全灭”信号送出
    temp = P2 & 0x1f;   // 恢复P2高3位为000
    P2 = temp;          // 取消选择，完成数据锁存
    
    // --- 步骤 2: 位选 (选择要点亮的数码管位置) ---
    // 通过P0口送出位选数据。例如 wela=0, P0=0x01; wela=1, P0=0x02 ...
    // 这个信号会送到位选锁存器，使其只打开对应一位数码管的公共阳极。
    P0 = 0x01 << wela;
    
    // 使用138译码器选择位选锁存器（Y6输出，地址110）
    temp = P2 & 0x1f;
    temp = temp | 0xc0;   // 设置P2高3位为110 (0xc0 = 1100 0000b)
    P2 = temp;
    temp = P2 & 0x1f;
    P2 = temp;
    
    // --- 步骤 3: 段选 (在该位置上显示指定内容) ---
    // 从段码表中取出要显示的数字/字符的编码
    P0 = seg_dula[dula];
    
    // 如果需要点亮小数点
    if(point)
    {
        // 将段码的最高位(DP段)强制清零，以点亮小数点。
        // 0x7f = 0111 1111b。P0 & 0x7f 会使bit7变为0，其他位不变。
        P0 &= 0x7f;
    }
    
    // 再次使用138译码器选择段选锁存器（Y7输出，地址111）
    // 将P0上准备好的段码数据发送给所有数码管的段引脚。
    // 但因为只有在“位选”步骤中选中的那一位的阳极是通的，所以只有那一位会显示。
    temp = P2 & 0x1f;
    temp = temp | 0xe0;
    P2 = temp;
    temp = P2 & 0x1f;
    P2 = temp;
}