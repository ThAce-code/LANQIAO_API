#include "key.h" // 包含了按键相关的头文件

/**
 * @brief   读取按键函数
 * @param   无
 * @return  unsigned char - 返回按键值。如果没有按键按下或检测到串口通信，返回0。
 * @note    此函数实现了对一个3x4（可配置为4x4）矩阵键盘的扫描。
 * 一个关键的设计是：它必须与串行通信和频率测量功能和谐共存。
 * P3.0口同时用作按键扫描的列线和UART的接收线(RXD)。
 * P3.4口被保留用于频率测量。
 * 为防止冲突，函数在扫描前会检查P3.0的状态。
 */
unsigned char Key_Read()
{
    
    unsigned char temp=0; // 初始化返回值为0 (无按键)

    // --- 独立按键（已注释） ---
    // 这部分代码是为独立按键设计的，当前未使用。
    /*
    if(P30==0)temp=7;
    if(P31==0)temp=6;
    if(P32==0)temp=5;
    if(P33==0)temp=4;
    */
    
    // --- 矩阵按键扫描开始 ---
    // 兼容性说明：如果需要测量频率，那么必须注释P34相关的所有东西。
    
    // --- 扫描第一行 (由 P4.4 控制) ---
    // 准备阶段：将所有正在使用的行线设置为高电平。
    P44=1;P42=1;P35=1;//P34=1;
    
    // *** 关键的串口冲突检测 ***
    // P3.0是串口RXD引脚。当串口接收数据时，起始位会将其拉低。
    // 此行代码检查P3.0是否为低。如果为低，说明串口可能正在接收数据。
    // 为避免将串口信号误判为按键，或干扰串口通信，函数立即退出并返回0。
    if(P30==0)return 0; 
    
    // 核心操作：将第一行线(P4.4)拉低，其他行线保持高电平。
    P44=0;P42=1;P35=1;//P34=1;
    if(P30==0)temp=7;  // 检测第一列(P3.0)，如果为低电平，说明S7键被按下。
    if(P31==0)temp=6;  // 检测第二列(P3.1)，如果为低电平，说明S6键被按下。
    if(P32==0)temp=5;  // 检测第三列(P3.2)，如果为低电平，说明S5键被按下。
    if(P33==0)temp=4;  // 检测第四列(P3.3)，如果为低电平，说明S4键被按下。
    
    // --- 扫描第二行 (由 P4.2 控制) ---
    // 恢复所有行线为高电平，结束上一行的扫描。
    P44=1;P42=1;P35=1;//P34=1;
    
    // 再次进行串口冲突检测
    if(P30==0)return 0; 
    
    // 核心操作：将第二行线(P4.2)拉低。
    P44=1;P42=0;P35=1;//P34=1;
    if(P30==0)temp=11; // 检测S11键。
    if(P31==0)temp=10; // 检测S10键。

    // 这是一个非常特殊的组合键检测
    if((P32==0)&&(P33==0))return 89; // 如果S9和S8同时被按下，立即返回一个特殊值89。

    if(P32==0)temp=9;  // 检测S9键。
    if(P33==0)temp=8;  // 检测S8键。
    
    // --- 扫描第三行 (由 P3.5 控制) ---
    // 恢复所有行线为高电平。
    P44=1;P42=1;P35=1;//P34=1;
    
    // 再次进行串口冲突检测
    if(P30==0)return 0;
    
    // 核心操作：将第三行线(P3.5)拉低。
    P44=1;P42=1;P35=0;//P34=1;
    if(P30==0)temp=15; // 检测S15键。
    if(P31==0)temp=14; // 检测S14键。
    if(P32==0)temp=13; // 检测S13键。
    if(P33==0)temp=12; // 检测S12键。
    
    // --- 扫描第四行 (已为频率测量功能注释掉) ---
    // 如果启用这部分，P3.4引脚将被用于按键扫描，从而无法用于频率测量。
    /*
        P44=1;P42=1;P35=1;P34=1;
        if(P30==0)return 0;
        P44=1;P42=1;P35=1;P34=0;
        if(P30==0)temp=19; // S19
        if(P31==0)temp=18; // S18
        if(P32==0)temp=17; // S17
        if(P33==0)temp=16; // S16
    */

    // --- 扫描结束，恢复端口状态 ---
    // 确保所有行线在函数退出时都恢复为高电平。
    P44=1;P42=1;P35=1;//P34=1;
    
    // 下面这行代码是为了在不影响P3.4（频率测量引脚）的情况下，将P3口的其他引脚设置为高阻输入状态。
    // 在8051架构中，向端口位写入'1'会使其配置为高阻输入，为下一次正确读取做准备。
    // 0xef = 1110 1111b，通过按位或操作，P3.4保持原样，其他位被置1。
    P3=P3|0xef;
    
    return temp; // 返回检测到的按键值，或0（无按键/串口忙）。
}