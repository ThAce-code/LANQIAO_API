/* #   DS1302代码片段说明
	1.  本文件夹中提供的驱动代码供参赛选手完成程序设计参考。
	2.  参赛选手可以自行编写相关代码或以该代码为基础，根据所选单片机类型、运行速度和试题
		中对单片机时钟频率的要求，进行代码调试和修改。
*/
#include "ds1302.h"	 // 包含了DS1302相关寄存器地址和命令的宏定义
#include "intrins.h" // 包含了Keil C51编译器提供的内部函数，如_nop_()

// --- 引脚定义 ---
// 使用sbit关键字为DS1302的三个通信引脚定义别名，方便后续代码调用
sbit SCK = P1 ^ 7; // SCLK (Serial Clock) 时钟线，连接到单片机的P1.7口
sbit SDA = P2 ^ 3; // I/O (Data Input/Output) 数据线，连接到单片机的P2.3口
sbit RST = P1 ^ 3; // CE (Chip Enable) / RST (Reset) 复位/使能线，连接到单片机的P1.3口

/**
 * @brief 向DS1302发送一个字节的数据
 * @param temp 要发送的字节数据
 * @note  这是一个底层函数，负责按位（bit）串行发送数据。
 * 数据从最低位（LSB）开始发送。
 */
void Write_Ds1302(unsigned char temp)
{
	unsigned char i;
	for (i = 0; i < 8; i++) // 一个字节有8位，所以循环8次
	{
		SCK = 0;		   // 1. 拉低时钟线，准备在数据线上放置数据
		SDA = temp & 0x01; // 2. 取出temp变量的最低位，并将其发送到SDA数据线上
		temp >>= 1;		   // 3. 将temp右移一位，准备下一次循环发送新的最低位
		SCK = 1;		   // 4. 拉高时钟线，DS1302在SCK的上升沿读取SDA上的数据位
	}
}

/**
 * @brief 向DS1302的指定地址写入一个字节的数据
 * @param address 要写入的目标寄存器地址（命令字节）
 * @param dat 要写入的字节数据
 * @note  这是一个完整的单字节写操作流程。
 */
void Write_Ds1302_Byte(unsigned char address, unsigned char dat)
{
	RST = 0;
	_nop_(); // 1. 拉低RST引脚，准备开始通信
	SCK = 0;
	_nop_(); // 2. 确保时钟线在通信开始前是低电平
	RST = 1;
	_nop_(); // 3. 拉高RST引脚，使能DS1302，启动一次传输

	Write_Ds1302(address); // 4. 发送8位的地址/命令字节
	Write_Ds1302(dat);	   // 5. 发送8位的数据字节

	RST = 0; // 6. 拉低RST引脚，结束本次通信，DS1302不再侦听总线
}

/**
 * @brief 从DS1302的指定地址读取一个字节的数据
 * @param address 要读取的目标寄存器地址（命令字节）
 * @return unsigned char 返回从DS1302读取到的字节数据
 * @note  这是一个完整的单字节读操作流程。
 */
unsigned char Read_Ds1302_Byte(unsigned char address)
{
	unsigned char i, temp = 0x00;
	RST = 0;
	_nop_(); // 1. 准备通信，同写操作
	SCK = 0;
	_nop_();
	RST = 1;
	_nop_(); // 2. 使能DS1302，启动一次传输

	Write_Ds1302(address); // 3. 发送8位的地址/命令字节（读地址的最低位必须为1）

	for (i = 0; i < 8; i++) // 循环8次，接收一个字节的数据
	{
		SCK = 0;	// 4. 拉低时钟线，准备接收DS1302发出的数据
		temp >>= 1; // 5. 将temp右移一位，为即将到来的新数据位腾出空间（新位将放在最高位）
		if (SDA)	// 6. 读取SDA数据线上的电平。DS1302在SCK下降沿后将数据位放到SDA上
		{
			temp |= 0x80; // 7. 如果SDA为高电平（1），则将temp的最高位置1
		}
		SCK = 1; // 8. 拉高时钟线，DS1302在此上升沿后准备下一位数据
	}

	RST = 0;
	_nop_(); // 9. 拉低RST，结束通信

	// --- 总线状态恢复 ---
	// 以下操作确保SDA和SCK在通信结束后处于一个确定的空闲状态
	SCK = 0;
	_nop_();
	SCK = 1;
	_nop_();
	SDA = 0;
	_nop_();
	SDA = 1;
	_nop_();

	return (temp); // 10. 返回完整接收到的8位数据
}

/**
 * @brief 设置RTC（实时时钟）的时间
 * @param ucRtc 一个无符号字符数组的指针，ucRtc[0]存小时, ucRtc[1]存分钟, ucRtc[2]存秒
 * @note  例如，设置时间为11:12:13，需要传入一个数组，其内容为 {11, 12, 13}
 */
void Set_Rtc(unsigned char *ucRtc)
{
	unsigned char i;
	Write_Ds1302_Byte(0x8e, 0x00); // 1. 发送写保护寄存器地址(0x8E)，并写入0x00，表示关闭写保护

	// 2. 在设置时间前，先暂停时钟计时，防止在设置过程中秒、分、时进位。
	//    方法是向秒寄存器(地址0x80)的最高位(CH位)写入1。写入0x80即可实现。
	//    在后续的循环中，当写入新的秒数时，CH位会被自动清零（因为秒数小于60，其BCD码最高位必为0），时钟会自动恢复运行。
	Write_Ds1302_Byte(0x80, 0x80);

	for (i = 0; i < 3; i++) // 循环3次，分别写入小时、分钟、秒
	{
		// 3. 计算要写入的寄存器地址：
		//    当 i=0, 地址 = 0x84 - 0 = 0x84 (小时寄存器写地址)
		//    当 i=1, 地址 = 0x84 - 2 = 0x82 (分钟寄存器写地址)
		//    当 i=2, 地址 = 0x84 - 4 = 0x80 (秒寄存器写地址)

		// 4. 将十进制的ucRtc[i]转换为DS1302所需的BCD码格式，并写入对应寄存器
		//    转换公式: BCD = (DEC / 10 * 16) + (DEC % 10)
		//    例如，十进制的23: 23/10=2, 23%10=3, BCD = 2*16+3 = 35, 即十六进制的0x23
		Write_Ds1302_Byte(0x84 - 2 * i, ucRtc[i] / 10 * 16 + ucRtc[i] % 10);
	}
	Write_Ds1302_Byte(0x8e, 0x80); // 5. 时间设置完毕，重新开启写保护，防止数据被意外修改
}

/**
 * @brief 从RTC（实时时钟）读取当前时间
 * @param ucRtc 一个无符号字符数组的指针，用于存储读取到的时间。
 * ucRtc[0]将存小时, ucRtc[1]将存分钟, ucRtc[2]将存秒
 * @note  读取的结果是十进制格式。例如，读取到11:12:13，数组内容将是 {11, 12, 13}
 */
void Read_Rtc(unsigned char *ucRtc)
{
	unsigned char i;
	unsigned char temp;

	EA = 0; // 1. 关闭总中断。因为读取RTC是多字节操作，为防止在读操作过程中被中断打断导致数据错误，先关闭中断。

	for (i = 0; i < 3; i++) // 循环3次，分别读取小时、分钟、秒
	{
		// 2. 计算要读取的寄存器地址（读地址的最低位为1）：
		//    当 i=0, 地址 = 0x85 - 0 = 0x85 (小时寄存器读地址)
		//    当 i=1, 地址 = 0x85 - 2 = 0x83 (分钟寄存器读地址)
		//    当 i=2, 地址 = 0x85 - 4 = 0x81 (秒寄存器读地址)
		temp = Read_Ds1302_Byte(0x85 - 2 * i);

		// 3. 将从DS1302读取到的BCD码转换为十进制数
		//    转换公式: DEC = (BCD / 16 * 10) + (BCD % 16)
		//    例如，BCD码0x23: 0x23/16=2, 0x23%16=3, DEC = 2*10+3 = 23
		ucRtc[i] = temp / 16 * 10 + temp % 16;
	}

	EA = 1; // 4. 读取操作完成，重新开启总中断。
}

